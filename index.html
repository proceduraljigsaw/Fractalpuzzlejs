<!DOCTYPE html>
<html>

<head>
   <!-- HTML and several functions based or copied from https://github.com/Draradech/jigsaw -->
   <meta charset="UTF-8">
   <title>Fractal jigsaw puzzle generator</title>
   <script type="text/javascript">

      var seed = 1;
      var ncols, nrows, rad, frame, framecorner, minp, maxp, coloring_seed = 1;
      var arc_shape = 0;
      var jig;
      var customborder = {};
      function random() {
         if ($("ndr").checked) {
            return Math.random();
         } else {
            var x = Math.sin(seed) * 10000; seed += 1; return x - Math.floor(x);
         }
      }
      function uniform(min, max) { var r = random(); return min + r * (max - min); }
      function rbool() { return random() > 0.5; }

      function $(id) { return document.getElementById(id); }

      function updateseed() { $("_seed").value = $("seed").value; update(); }
      function updatencols() { $("_ncols").value = $("ncols").value; update(); }
      function updatenrows() { $("_nrows").value = $("nrows").value; update(); }
      function update_seed() { var val = parseInt($("_seed").value); if (!isNaN(val)) { $("seed").value = val; } updateseed(); }
      function update_ncols() { var val = parseInt($("_ncols").value); if (!isNaN(val)) { $("ncols").value = val; } updatencols(); }
      function update_nrows() { var val = parseInt($("_nrows").value); if (!isNaN(val)) { $("nrows").value = val; } updatenrows(); }


      function factorial(n) {
         if (n < 0)
            return (-1); /*Wrong value*/
         if (n == 0)
            return (1);  /*Terminating condition*/
         else {
            return (n * factorial(n - 1));
         }
      }

      function nCr(n, r) {
         return (factorial(n) / (factorial(r) * factorial(n - r)));
      }
      class Bezier {
         constructor(points) {
            this.points = points;
            switch (this.points.length) {
               case 2:
                  this.type = 'L';
                  break;
               case 3:
                  this.type = 'Q';
                  break;
               case 4:
                  this.type = 'C';
                  break;
               default:
                  this.type = 'x';
            }
         }
         stype() {
            return this.type;
         }
         pts() {
            return this.points;
         }
         svg(offset) {
            if (this.points.length == 4) {
               return "C " + ((this.points[1].x + offset)) + " " + (this.points[1].y + offset) + ", " + (this.points[2].x + offset) + " " + (this.points[2].y + offset) + ", " + (this.points[3].x + offset) + " " + (this.points[3].y + offset) + " ";
            }
            if (this.points.length == 3) {
               return "Q " + (this.points[1].x + offset) + " " + (this.points[1].y + offset) + ", " + (this.points[2].x + offset) + " " + (this.points[2].y + offset) + " ";
            }
            if (this.points.length == 2) {
               return "L " + (this.points[1].x + offset) + " " + (this.points[1].y + offset) + " ";
            }
         }
         bzpoint(u, scale) {
            let n = this.points.length;
            let p = { x: 0, y: 0, rx: 0, ry: 0 };

            for (let i = 0; i < n; i++) {
               let B = nCr(n - 1, i) * Math.pow((1 - u), (n - 1) - i) * Math.pow(u, i);
               let px = this.points[i].x * B;
               let py = this.points[i].y * B;

               p.x += px;
               p.y += py;

            }
            p.rx = p.x;
            p.ry = p.y;
            p.x = Math.round(p.x / scale);
            p.y = Math.round(p.y / scale);
            return p;
         }
         enhance(pts, ustart, uend, uinc, scale) {
            for (let u = ustart; u < uend; u += uinc) {
               let p = this.bzpoint(u, scale);
               var pp = pts[pts.length - 1];
               if (Math.abs(pp.x - p.x) > 1 || Math.abs(pp.y - p.y) > 1) {
                  let nuinc = uinc / 2;
                  this.enhance(pts, u - uinc + nuinc, u, nuinc, scale);
               }
               pts.push(p);
            }
         }
         plot(scale) {
            let curvepoints = [];
            for (let u = 0; u <= 1; u += 0.001) {
               let p = this.bzpoint(u, scale);
               if (curvepoints.length) {
                  var pp = curvepoints[curvepoints.length - 1];
                  if (Math.abs(pp.x - p.x) > 1 || Math.abs(pp.y - p.y) > 1) {
                     //Lacking raster resolution
                     let nuinc = 0.001 / 2;
                     this.enhance(curvepoints, u - 0.001 + nuinc, u, nuinc, scale);
                  }
               }
               curvepoints.push(p);
            }
            return curvepoints;
         }
      }


      function d2r(deg) {
         var pi = Math.PI;
         return deg * (pi / 180);
      }
      function r2d(radians) {
         var pi = Math.PI;
         return radians * (180 / pi);
      }
      function dot(v1, v2) {
         var ret = 0;
         for (var i = 0; i < v1.length; i++) {
            ret += v1[i] * v2[i];
         }
         return ret;
      }

      function norm(v) {
         return Math.sqrt(dot(v, v));
      }

      function av(v1, v2) {
         var dp = dot(v1, v2);
         var n = norm(v1) * norm(v2);
         var s = (v1[0] * v2[1] - v1[1] * v2[0]) > 0 ? 1 : -1;
         return s * Math.acos(dp / n);
      }
      class SVGArc {
         constructor(sp, rx, ry, xr, laf, sf, ep) {
            this.type = 'A';
            this.sp = sp;
            this.rx = rx;
            this.ry = ry;
            this.xr = xr;
            this.laf = laf;
            this.sf = sf;
            this.ep = ep;
            var phi = d2r(xr);
            var cosphi = Math.cos(phi);
            var sinphi = Math.sin(phi);

            var x1m = (sp.x - ep.x) / 2;
            var y1m = (sp.y - ep.y) / 2;

            var x1p = cosphi * x1m + sinphi * y1m;
            var y1p = cosphi * y1m - sinphi * x1m;

            var rx2 = rx * rx;
            var ry2 = ry * ry;

            var x1p2 = x1p * x1p;
            var y1p2 = y1p * y1p;

            var lsqrt = Math.sqrt((rx2 * ry2 - rx2 * y1p2 - ry2 * x1p2) / (rx2 * y1p2 + ry2 * x1p2));
            if (laf == sf) {
               lsqrt = -lsqrt;
            }
            var cxp = lsqrt * (rx * y1p / ry);
            var cyp = -lsqrt * (ry * x1p / rx);

            var cx = cosphi * cxp - sinphi * cyp + (sp.x + ep.x) / 2;
            var cy = sinphi * cxp + cosphi * cyp + (sp.y + ep.y) / 2;

            var th1 = r2d(av([1, 0], [((x1p - cxp) / rx), ((y1p - cyp) / ry)]));
            var deltath = r2d(av([((x1p - cxp) / rx), ((y1p - cyp) / ry)], [((-x1p - cxp) / rx), ((-y1p - cyp) / ry)])) % 360;

            if (!sf && deltath > 0) {
               deltath -= 360;
            }
            if (sf && deltath < 0) {
               deltath += 360;
            }
            this.c = { x: cx, y: cy };
            this.th1 = d2r(th1);
            this.deltath = d2r(deltath);
            this.cosphi = cosphi;
            this.sinphi = sinphi;
         }

         pts() {
            return [this.sp, this.ep];
         }

         stype() {
            return this.type;
         }

         svg(offset) {
            return "A " + this.rx + " " + this.ry + " " + this.xr + " " + (this.laf ? "1 " : "0 ") + (this.sf ? "1 " : "0 ") + ((this.ep.x + offset)) + " " + (this.ep.y + offset) + " ";
         }

         arcpoint(th, scale) {
            let p = { x: 0, y: 0, rx: 0, ry: 0 };
            p.x = this.cosphi * this.rx * Math.cos(th) - this.sinphi * this.ry * Math.sin(th) + this.c.x;
            p.y = this.sinphi * this.rx * Math.cos(th) + this.cosphi * this.ry * Math.sin(th) + this.c.y;

            p.rx = p.x;
            p.ry = p.y;
            p.x = Math.round(p.x / scale);
            p.y = Math.round(p.y / scale);
            return p;
         }
         enhance(pts, ustart, uend, uinc, scale) {
            for (let u = ustart; u < uend; u += uinc) {
               let p = this.arcpoint(u * this.deltath + this.th1, scale);
               var pp = pts[pts.length - 1];
               if (Math.abs(pp.x - p.x) > 1 || Math.abs(pp.y - p.y) > 1) {
                  let nuinc = uinc / 2;
                  this.enhance(pts, u - uinc + nuinc, u, nuinc, scale);
               }
               pts.push(p);
            }
         }
         plot(scale) {
            let curvepoints = [];
            for (let u = 0; u <= 1; u += 0.001) {
               let p = this.arcpoint(u * this.deltath + this.th1, scale);
               if (curvepoints.length) {
                  var pp = curvepoints[curvepoints.length - 1];
                  if (Math.abs(pp.x - p.x) > 1 || Math.abs(pp.y - p.y) > 1) {
                     //Lacking raster resolution
                     let nuinc = 0.001 / 2;
                     this.enhance(curvepoints, u - 0.001 + nuinc, u, nuinc, scale);
                  }
               }
               curvepoints.push(p);
            }
            return curvepoints;
         }
      }


      class Tile {
         constructor(x, y) {
            this._x = x;
            this._y = y;
            this.haspossibleconnections = true;
         }
         get hasconnections() {
            return this.haspossibleconnections;
         }
         set hasconnections(val) {
            this.haspossibleconnections = val;
         }
         get x() {
            return this._x;
         }
         get y() {
            return this._y;
         }
         eq(p) {
            return (this.x == p.x && this.y == p.y);
         }
      }

      class Cell {
         constructor(x, y) {
            this._x = x;
            this._y = y;
         }
         get x() {
            return this._x;
         }
         get y() {
            return this._y;
         }
         eq(c) {
            return (this.x == c.x && this.y == c.y);
         }
      }

      class DiagonalConnection {
         constructor(p1, p2, p2_taken) {
            this._p1 = p1;
            this._p2 = p2;
            this._p2_taken = p2_taken;
            this._slope = (p2.y - p1.y) / (p2.x - p1.x);
            var ccx = Math.min(p2.x, p1.x);
            var ccy = Math.min(p2.y, p1.y);
            this._cell = new Cell(ccx, ccy);
            if (this._slope > 0) {
               if (p2.y > p1.y) {
                  this._quad = 3;
               } else {
                  this._quad = 1;
               }
            } else {
               if (p2.y > p1.y) {
                  this._quad = 2;
               } else {
                  this._quad = 0;
               }
            }
         }
         eq(other) {
            return (this === other) || (this.cell.x == other.cell.x && this.cell.y == other.cell.y && this.slope == other.slope && this.p2_taken == other.p2_taken)
         }
         get slope() {
            return this._slope;
         }
         get quad() {
            return this._quad;
         }
         get p1() {
            return this._p1;
         }
         get p2() {
            return this._p2;
         }
         get cell() {
            return this._cell;
         }

         get p2_taken() {
            return this._p2_taken
         }
         static FromPointAndQuad(p1, quadrant, p2_taken) {
            var p2;
            switch (quadrant) {
               case 0:
                  p2 = new Tile(p1.x + 1, p1.y - 1);
                  break;
               case 1:
                  p2 = new Tile(p1.x - 1, p1.y - 1);
                  break;
               case 2:
                  p2 = new Tile(p1.x - 1, p1.y + 1);
                  break;
               case 3:
                  p2 = new Tile(p1.x + 1, p1.y + 1);
                  break;
            }
            return new DiagonalConnection(p1, p2, p2_taken);
         }
      }


      class CellGrid {
         constructor(nrow, ncol) {
            this.nrow = nrow;
            this.ncol = ncol;
            this.visited = new Array(this.ncol * this.nrow).fill(false);
            this.cellmap = new Array((this.ncol - 1) * (this.nrow - 1)).fill(false);
            this._nunvisited = this.ncol * this.nrow;
         }

         randomemptytile() {
            var emptytiles = this.visited.reduce(function (acc, curr, index) {
               if (!curr) {
                  acc.push(index);
               }
               return acc;
            }, []);

            var index = emptytiles[Math.floor(uniform(0, emptytiles.length))];
            var y = Math.floor(index / this.nrow);
            var x = index % this.nrow;
            return new Tile(x, y);
         }

         reset() {
            this.visited.fill(false);
            this.cellmap.fill(false);
            this._nunvisited = this.ncol * this.nrow;
         }
         istilevalid(v) {
            return (v.x >= 0 && v.x < this.nrow && v.y >= 0 && v.y < this.ncol);
         }

         istilevisited(v) {
            return this.visited[v.y * this.nrow + v.x];
         }
         iscellempty(c) {
            return !this.cellmap[c.y * this.nrow + c.x];
         }
         visittile(v) {
            if (!this.visited[v.y * this.nrow + v.x]) {
               this.visited[v.y * this.nrow + v.x] = true;
               this._nunvisited--;
            }
         }
         occupycell(c) {
            if (!this.cellmap[c.y * this.nrow + c.x]) {
               this.cellmap[c.y * this.nrow + c.x] = true;
            }
         }
         liberatecell(c) {
            this.cellmap[c.y * this.nrow + c.x] = false;
         }

         get nunvisited() {
            return this._nunvisited;
         }

         get notvisited() {
            return this._notvisited;
         }

      }

      class Arc {
         constructor(gcp, rad, offs, quad, sign) {
            this._cp = new Tile(gcp.x * 2 * rad + rad + offs, gcp.y * 2 * rad + rad + offs);
            this._quad = quad;
            this._rad = rad;
            this._sign = sign
            var pa;
            var pb;
            switch (quad) {
               case 0:
                  pa = new Tile(this._cp.x + rad, this._cp.y);
                  pb = new Tile(this._cp.x, this._cp.y - rad);
                  break;
               case 1:
                  pa = new Tile(this._cp.x, this._cp.y - rad);
                  pb = new Tile(this._cp.x - rad, this._cp.y);
                  break;
               case 2:
                  pa = new Tile(this._cp.x - rad, this._cp.y);
                  pb = new Tile(this._cp.x, this._cp.y + rad);
                  break;
               case 3:
                  pa = new Tile(this._cp.x, this._cp.y + rad);
                  pb = new Tile(this._cp.x + rad, this._cp.y);
                  break;
            }
            if (this.sign == 0) {
               this._sp = pa;
               this._ep = pb;
            } else {
               this._sp = pb;
               this._ep = pa;
            }
         }
         svg(arcshape) {
            const tan225 = 0.4142135623730950488016887242097;
            var hlen = this._rad * tan225;
            switch (arcshape) {
               case 0: //circle arc
                  return "A " + this._rad + " " + this._rad + " 0 0," + this.sign + " " + this.ep.x + " " + this.ep.y + " ";
                  break;
               case 1: //square
                  return "L " + this.ep.x + " " + this.ep.y + " ";
                  break;
               case 2: //octagon
                  var quad = this._quad;
                  var sp = this.sp;
                  var ep = this.ep;
                  if (this._sign == 1) {
                     sp = this.ep;
                     ep = this.sp;
                  }
                  switch (quad) {
                     case 0:
                        var mp1 = [sp.x, sp.y - hlen];
                        var mp2 = [ep.x + hlen, ep.y];
                        break;
                     case 1:
                        var mp1 = [sp.x - hlen, sp.y];
                        var mp2 = [ep.x, ep.y - hlen];
                        break;
                     case 2:
                        var mp1 = [sp.x, sp.y + hlen];
                        var mp2 = [ep.x - hlen, ep.y];
                        break;
                     case 3:
                        var mp1 = [sp.x + hlen, sp.y];
                        var mp2 = [ep.x, ep.y + hlen];
                        break;
                  }
                  if (this._sign == 1) {
                     return "L " + mp2[0] + " " + mp2[1] + " L " + mp1[0] + " " + mp1[1] + " L " + this.ep.x + " " + this.ep.y + " ";
                  } else {
                     return "L " + mp1[0] + " " + mp1[1] + " L " + mp2[0] + " " + mp2[1] + " L " + this.ep.x + " " + this.ep.y + " ";
                  }
                  break;
            }
         }
         eq(a) {
            return (this.quad == a.quad && this.cp.eq(a.cp));
         }
         get cp() {
            return this._cp;
         }
         get sign() {
            return this._sign;
         }
         get sp() {
            return this._sp;
         }
         get ep() {
            return this._ep;
         }
         get quad() {
            return this._quad;
         }
      }
      class CircleFractalJigsaw {
         constructor(ncols, nrows, minpiecelen, maxpiecelen, border, crad) {
            let Array2D = (row, col) => [...Array(row)].map(x => Array(col).fill(0));

            if (border.paths) {
               ncols = Math.ceil(border.width / (2 * crad)) + 1;
               nrows = Math.ceil(border.height / (2 * crad)) + 1;
            }
            this.ncols = ncols;
            this.nrows = nrows;
            this.maskgrid = Array2D(nrows, ncols);
            this.grid = new CellGrid(ncols, nrows)
            if (border.paths) {
               this.fillmask(border.paths, crad, parseFloat($("frame").value));
               for (var i = 0; i < nrows; i++) {
                  for (var j = 0; j < ncols; j++) {
                     if (this.maskgrid[i][j]) {
                        this.grid.visittile({ x: j, y: i });
                     }
                  }
               }
            }
            this.pieces = [];
            this.maxpiecelen = maxpiecelen;
            this.minpiecelen = minpiecelen;

         }

         fillmask(paths, crad, frame) {
            const crosslookup = [[-1, 0], [1, 0], [0, 1], [0, -1]];
            var dia = 2 * crad;
            var allpts = []
            var minx, miny, maxx, maxy
            paths.forEach((p) => {
               p.forEach((seg) => {
                  var pts = seg.plot(dia);
                  pts.forEach((pt) => {
                     allpts.push(pt);
                     if (isNaN(minx) || pt.x < minx) minx = pt.x;
                     if (isNaN(miny) || pt.y < miny) miny = pt.y;
                     if (isNaN(maxx) || pt.x > maxx) maxx = pt.x;
                     if (isNaN(maxy) || pt.y > maxy) maxy = pt.y;

                  });
               });

            });
            // console.log("V", minx, maxx, miny, maxy);
            allpts.forEach((p) => {

               this.maskgrid[p.y][p.x] = 1;

            });

            var regnum = 3;

            var grown;
            do {
               var outside = true;
               grown = false;
               for (var i = -1; i < this.nrows + 1; i++) {
                  for (var j = -1; j < this.ncols + 1; j++) {
                     if (i < 0 || j < 0 || i > this.nrows - 1 || j > this.ncols - 1 || (this.maskgrid[i][j] > 1 && this.maskgrid[i][j] < regnum)) {
                        var togrow = [{ r: i, c: j }];
                        do {
                           var p = togrow.pop();
                           crosslookup.forEach((c) => {
                              var ii = p.r + c[0];
                              var jj = p.c + c[1];
                              if (ii >= 0 && jj >= 0 && ii < this.nrows && jj < this.ncols) {

                                 if (!this.maskgrid[ii][jj]) {
                                    togrow.push({ r: ii, c: jj });
                                 }
                                 if (this.maskgrid[ii][jj] < 2) {
                                    if (p.r > 0 && p.c > 0 && p.r < this.nrows && p.c < this.ncols) {
                                       if (this.maskgrid[p.r][p.c] > 1 && this.maskgrid[p.r][p.c] < regnum && this.maskgrid[p.r][p.c] % 2) {
                                          this.outside = false;
                                       }
                                    } else {
                                       this.outside = true;
                                    }
                                    this.maskgrid[ii][jj] = regnum;
                                    grown = true;
                                 }
                              }
                           });
                        } while (togrow.length);

                     }
                  }

               }
               regnum += outside ? 1 : 2;
            } while (grown)

            for (var i = 0; i < this.nrows; i++) {
               for (var j = 0; j < this.ncols; j++) {
                  this.maskgrid[i][j] = this.maskgrid[i][j] % 2;
               }
            }
            allpts.forEach((p) => {
               this.maskgrid[p.y][p.x] = 1;
               var bordered = false;
               var extent = 1;
               while (!bordered) {
                  bordered = true;
                  for (var i = -extent; i < extent + 1; i++) {
                     for (var j = -extent; j < extent + 1; j++) {
                        if (Math.abs(i) == extent || Math.abs(j) == extent) {
                           var cx = p.x + i;
                           var cy = p.y + j;
                           if (cx > 0 && cy > 0 && cx < this.ncols && cy < this.nrows) {
                              // console.log(extent);
                              //console.log(Math.hypot(cx * 2 * crad - p.rx, cy * 2 * crad - p.ry));
                              // console.log(crad + frame);
                              if (Math.hypot(cx * 2 * crad - p.rx, cy * 2 * crad - p.ry) < crad + frame) {
                                 this.maskgrid[cy][cx] = 1;
                                 bordered = false;
                              }
                           }
                        }

                     }
                  }
                  extent++;
               }
               // console.log("bordered");
            });
         }

         possibleconnections(mytiles, allowpartials) {
            var pcs = [];
            var neighbors = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            mytiles.forEach((v) => {
               if (v.hasconnections || allowpartials) {
                  v.hasconnections = false;
                  neighbors.forEach((n) => {
                     let cpt = new Tile(v.x + n[0], v.y + n[1]);
                     if (this.grid.istilevalid(cpt) && !this.maskgrid[cpt.y][cpt.x] && !mytiles.find(nv => nv.eq(cpt))) {
                        let dc = new DiagonalConnection(v, cpt, !this.grid.istilevisited(cpt));
                        if (this.grid.iscellempty(dc.cell)) {
                           if (allowpartials || !this.grid.istilevisited(cpt)) {
                              pcs.push(dc);
                              v.hasconnections = true;
                           }
                        }
                     }
                  });
               }
            });
            return pcs;
         }
         createpiece() {
            var mytiles = new Array();
            var myconnections = new Array();
            var targetpiecelen = Math.round(uniform(this.minpiecelen, this.maxpiecelen));
            var vi = this.grid.randomemptytile();
            mytiles.push(vi);
            this.grid.visittile(vi);


            while (this.grid.nunvisited > 0 && mytiles.length < targetpiecelen) {
               var possibleconnections = this.possibleconnections(mytiles, false);
               if (possibleconnections.length == 0) {
                  break;
               }
               var chosenconnection = possibleconnections[Math.floor(uniform(0, possibleconnections.length))];
               myconnections.push(chosenconnection);
               mytiles.push(chosenconnection.p2);
               this.grid.occupycell(chosenconnection.cell);
               this.grid.visittile(chosenconnection.p2);


            }

            if (mytiles.length >= this.minpiecelen) {
               this.pieces.push(myconnections);
            } else {
               myconnections.forEach((c) => {
                  this.grid.liberatecell(c.cell);
               })
            }
         }

         fillholes(allowpartials) {
            var filled = false;
            this.pieces = this.pieces.sort((a, b) => a.length - b.length);
            this.pieces.forEach((p) => {
               var tiles = [p[0].p1];
               p.forEach((con) => {
                  tiles.push(con.p2);
               });
               tiles.forEach((v) => {
                  var possibleconnections = this.possibleconnections([v], allowpartials);
                  if (possibleconnections.length) {
                     possibleconnections = possibleconnections.filter(function (ele) {
                        return !Boolean(tiles.find(vf => vf.eq(ele.p2)));
                     });
                     possibleconnections.forEach((pc) => {
                        p.push(pc);
                        tiles.push(pc.p2);
                        filled = true;
                        this.grid.occupycell(pc.cell);
                        this.grid.visittile(pc.p2);
                     });
                  }
               });

            });
            return filled;
         }


         static addarcs(con, connections, arcs, rad, frame, first) {
            var newarc;
            switch (con.quad) {
               case 0:
                  newarc = new Arc(new Tile(con.p1.x + 1, con.p1.y), rad, frame, 1, 1);
                  break;
               case 1:
                  newarc = new Arc(new Tile(con.p1.x, con.p1.y - 1), rad, frame, 2, 1);
                  break;
               case 2:
                  newarc = new Arc(new Tile(con.p1.x - 1, con.p1.y), rad, frame, 3, 1);
                  break;
               case 3:
                  newarc = new Arc(new Tile(con.p1.x, con.p1.y + 1), rad, frame, 0, 1);
                  break;
            }
            arcs.push(newarc);
            if (con.p2_taken) {
               var p2quads = [(con.quad + 3) % 4, (con.quad + 4) % 4, (con.quad + 5) % 4];
               p2quads.forEach((q) => {
                  var pct = DiagonalConnection.FromPointAndQuad(con.p2, q, true);
                  var pcnt = DiagonalConnection.FromPointAndQuad(con.p2, q, false);
                  if (connections.find(c => c.eq(pct))) {
                     CircleFractalJigsaw.addarcs(pct, connections, arcs, rad, frame, false);
                  } else if (connections.find(c => c.eq(pcnt))) {
                     CircleFractalJigsaw.addarcs(pcnt, connections, arcs, rad, frame, false);
                  } else {
                     arcs.push(new Arc(con.p2, rad, frame, q, 0));
                  }
               });
            } else {
               arcs.push(new Arc(con.p2, rad, frame, (con.quad + 2) % 4, 1));
            }

            switch (con.quad) {

               case 0:
                  newarc = new Arc(new Tile(con.p1.x, con.p1.y - 1), rad, frame, 3, 1);
                  break;
               case 1:
                  newarc = new Arc(new Tile(con.p1.x - 1, con.p1.y), rad, frame, 0, 1);
                  break;
               case 2:
                  newarc = new Arc(new Tile(con.p1.x, con.p1.y + 1), rad, frame, 1, 1);
                  break;
               case 3:
                  newarc = new Arc(new Tile(con.p1.x + 1, con.p1.y), rad, frame, 2, 1);
                  break;
            }
            arcs.push(newarc);

            if (first) {
               var p1quads = [(con.quad + 1) % 4, (con.quad + 2) % 4, (con.quad + 3) % 4];
               p1quads.forEach((q) => {
                  var pct = DiagonalConnection.FromPointAndQuad(con.p1, q, true);
                  var pcnt = DiagonalConnection.FromPointAndQuad(con.p1, q, false);
                  if (connections.find(c => c.eq(pct))) {
                     CircleFractalJigsaw.addarcs(pct, connections, arcs, rad, frame, false);
                  } else if (connections.find(c => c.eq(pcnt))) {
                     CircleFractalJigsaw.addarcs(pcnt, connections, arcs, rad, frame, false);
                  } else {
                     arcs.push(new Arc(con.p1, rad, frame, q, 0));
                  }
               });
            }

         }

         exportsvg(frame, crad, arcshape) {
            var width = this.ncols * 2 * crad + 2 * frame;
            var height = this.nrows * 2 * crad + 2 * frame;

            var data = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><svg baseProfile=\"full\" height=\"" + height + "mm\" version=\"1.1\" viewBox=\"0 0 " + width + " " + height + "\" width=\"" + width + "mm\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:ev=\"http://www.w3.org/2001/xml-events\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><defs />"

            this.pieces.forEach((p) => {
               var arcs = [];
               CircleFractalJigsaw.addarcs(p[0], p, arcs, crad, frame, true);
               data += "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"M" + arcs[0].sp.x + "," + arcs[0].sp.y + " ";
               arcs.forEach((a) => {
                  data += a.svg(arcshape);
               });
               data += "Z\"></path>";
            });
            if (customborder.paths) {
               customborder.paths.forEach((p) => {
                  data += "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"";
                  data += "M " + (p[0].pts()[0].x + rad) + ", " + (p[0].pts()[0].y + rad) + " "
                  p.forEach((seg) => {
                     data += seg.svg(rad);
                  });
                  data += "\"></path>";
               });
            } else {
               data += "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"" + createframe() + "\"></path>";
            }
            data += "</svg>";
            return data;
         }
         exportsvg_nooverlap_singlepath(frame, crad, arcshape) {
            var width = this.ncols * 2 * crad + 2 * frame;
            var height = this.nrows * 2 * crad + 2 * frame;
            var data = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><svg baseProfile=\"full\" height=\"" + height + "mm\" version=\"1.1\" viewBox=\"0 0 " + width + " " + height + "\" width=\"" + width + "mm\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:ev=\"http://www.w3.org/2001/xml-events\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><defs />"
            var allarcs = [];
            data += "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"";
            var currentlocation = new Tile(-1, -1);
            this.pieces.forEach((p) => {
               var arcs = [];
               CircleFractalJigsaw.addarcs(p[0], p, arcs, crad, frame, true);
               arcs.forEach((a) => {
                  if (!allarcs.find(na => na.eq(a))) {
                     allarcs.push(a);
                     if (!a.sp.eq(currentlocation)) {
                        data += "M" + a.sp.x + "," + a.sp.y + " "
                     }
                     data += a.svg(arcshape);
                     currentlocation = a.ep;
                  }
               });
            });
            data += "\"></path>"
            if (customborder.paths) {
               customborder.paths.forEach((p) => {
                  data += "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"";
                  data += "M " + (p[0].pts()[0].x + rad) + ", " + (p[0].pts()[0].y + rad) + " "
                  p.forEach((seg) => {
                     data += seg.svg(rad);
                  });
                  data += "\"></path>";
               });
            } else {
               data += "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"" + createframe() + "\"></path>";
            }
            data += "</svg>";
            return data;
         }

         exportsvg_nooverlap(frame, crad, arcshape) {
            var width = this.ncols * 2 * crad + 2 * frame;
            var height = this.nrows * 2 * crad + 2 * frame;
            var data = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><svg baseProfile=\"full\" height=\"" + height + "mm\" version=\"1.1\" viewBox=\"0 0 " + width + " " + height + "\" width=\"" + width + "mm\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:ev=\"http://www.w3.org/2001/xml-events\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><defs />"
            var allarcs = [];
            var path = "";
            this.pieces.forEach((p) => {
               var inpath = false;
               var arcs = [];
               CircleFractalJigsaw.addarcs(p[0], p, arcs, crad, frame, true);
               arcs.forEach((a) => {
                  if (allarcs.find(na => na.eq(a))) {
                     if (inpath) {
                        path += "\"></path>"
                        data += path;
                        inpath = false;
                     }
                  } else {
                     allarcs.push(a);
                     if (!inpath) {
                        path = "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"M" + a.sp.x + "," + a.sp.y + " ";
                        inpath = true;
                     }
                     path += a.svg(arcshape);
                  }
               });
               if (inpath) {
                  path += "\"></path>"
                  data += path;
               }
            });
            if (customborder.paths) {
               customborder.paths.forEach((p) => {
                  data += "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"";
                  data += "M " + (p[0].pts()[0].x + rad) + ", " + (p[0].pts()[0].y + rad) + " "
                  p.forEach((seg) => {
                     data += seg.svg(rad);
                  });
                  data += "\"></path>";
               });
            } else {
               data += "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"" + createframe() + "\"></path>";
            }
            data += "</svg>";
            return data;
         }

         exportsvg_colored(border, crad, arcshape) {
            var width = this.ncols * 2 * crad + 2 * border;
            var height = this.nrows * 2 * crad + 2 * border;
            var data = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><svg baseProfile=\"full\" height=\"" + height + "mm\" version=\"1.1\" viewBox=\"0 0 " + width + " " + height + "\" width=\"" + width + "mm\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:ev=\"http://www.w3.org/2001/xml-events\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><defs />"
            seed = coloring_seed;
            this.multipaths(frame, rad, arcshape).forEach((p) => {
               data += "<path fill=\"#" + Math.floor(uniform(0, 16777216)).toString(16) + "\" stroke=\"black\" stroke-width=\"" + rad / 20.0 + "\" d=\"";
               data += p
               data += "\"></path>"
            });
            if (customborder.paths) {
               customborder.paths.forEach((p) => {
                  data += "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"";
                  data += "M " + (p[0].pts()[0].x + rad) + ", " + (p[0].pts()[0].y + rad) + " "
                  p.forEach((seg) => {
                     data += seg.svg(rad);
                  });
                  data += "\"></path>";
               });
            } else {
               data += "<path fill=\"none\" stroke=\"black\" stroke-width=\"0.1\" d=\"" + createframe() + "\"></path>";
            }
            data += "</svg>";
            return data;
         }

         multipaths(frame, crad, arcshape) {
            var paths = [];
            var data = "";
            this.pieces.forEach((p) => {
               var data = ""
               var arcs = [];
               CircleFractalJigsaw.addarcs(p[0], p, arcs, crad, frame, true);
               data += "M" + arcs[0].sp.x + "," + arcs[0].sp.y + " ";
               arcs.forEach((a) => {
                  data += a.svg(arcshape);
               });
               data += "Z"
               paths.push(data);
            });
            return paths;
         }
         generate() {
            while (this.grid.nunvisited) {
               this.createpiece();
            }
            this.regenerategrid();
         }
         npieces() {
            return this.pieces.length;
         }
         regenerategrid() {
            this.grid.reset()

            for (var i = 0; i < this.nrows; i++) {
               for (var j = 0; j < this.ncols; j++) {
                  if (this.maskgrid[i][j]) {
                     this.grid.occupycell({ x: j, y: i });
                  }
               }
            }
            var np = 1;
            this.pieces.forEach((p) => {
               p.forEach((c) => {
                  if (!this.grid.istilevisited(c.p1)) {
                     this.grid.visittile(c.p1);
                  }
                  if (c.p2_taken) {
                     if (!this.grid.istilevisited(c.p2)) {
                        this.grid.visittile(c.p2);
                     }
                  }
                  this.grid.occupycell(c.cell);
               });
               np++;
            });
         }

      }


      // save function pieced together from here: https://stackoverflow.com/questions/19327749/javascript-blob-filename-without-link
      function save(filename, data) {
         var blob = new Blob([data], { type: "image/svg+xml" });
         if (window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveBlob(blob, filename);
         }
         else {
            var elem = window.document.createElement('a');
            elem.href = window.URL.createObjectURL(blob);
            elem.download = filename;
            document.body.appendChild(elem);
            elem.click();
            document.body.removeChild(elem);
         }
      }



      function parse_input() {
         seed = parseInt($("seed").value);
         ncols = parseInt($("ncols").value);
         nrows = parseInt($("nrows").value);
         frame = parseFloat($("frame").value);
         framecorner = parseFloat($("framecorner").value);
         rad = parseFloat($("cradius").value);
         minp = parseInt($("minpsize").value);
         maxp = parseInt($("maxpsize").value);
      }


      function update() {
         parse_input();
         $("width").innerHTML = ncols * 2 * rad + 2 * frame;
         $("height").innerHTML = nrows * 2 * rad + 2 * frame;
      }
      function savesvg(mode) {
         switch (mode) {
            case 0:
               save("jigsaw.svg", jig.exportsvg(frame, rad, arc_shape));
               break;
            case 1:
               save("jigsaw.svg", jig.exportsvg_nooverlap(frame, rad, arc_shape));
               break;
            case 2:
               save("jigsaw.svg", jig.exportsvg_nooverlap_singlepath(frame, rad, arc_shape));
               break;
            case 3:
               save("jigsaw.svg", jig.exportsvg_colored(frame, rad, arc_shape));
               break;
         }

      }

      function createframe() {
         var width = ncols * 2 * rad + 2 * frame;
         var height = nrows * 2 * rad + 2 * frame;

         var data = "M" + framecorner + "," + 0 + " ";
         data += "H " + (width - framecorner);
         if (framecorner > 0) {
            data += "A " + framecorner + " " + framecorner + " 0 0,1 " + width + " " + framecorner + " ";
         }

         data += "V " + (height - framecorner);
         if (framecorner > 0) {
            data += "A " + framecorner + " " + framecorner + " 0 0,1 " + (width - framecorner) + " " + height + " ";
         }

         data += "H " + (framecorner);
         if (framecorner > 0) {
            data += "A " + framecorner + " " + framecorner + " 0 0,1 " + 0 + " " + (height - framecorner) + " ";
         }

         data += "V " + (framecorner);
         if (framecorner > 0) {
            data += "A " + framecorner + " " + framecorner + " 0 0,1 " + (framecorner) + " " + 0 + " ";
         }

         data += "Z";
         return data;
      }

      function generate() {
         parse_input();
         if (customborder.paths) {
            frame = 0;
            $("width").innerHTML = customborder.width;
            $("height").innerHTML = customborder.height;
         }
         jig = new CircleFractalJigsaw(ncols, nrows, minp, maxp, customborder, rad);
         nrows = jig.nrows;
         ncols = jig.ncols;

         jig.generate();
         while (jig.fillholes(false));
         jig.fillholes(true);

         $("puzzlecontainer").setAttribute("width", ncols * 2 * rad + 2 * frame);
         $("puzzlecontainer").setAttribute("height", nrows * 2 * rad + 2 * frame);
         if ($("octagonal").checked) {
            arc_shape = 2;
         }
         if ($("square").checked) {
            arc_shape = 1;
         }
         if ($("circular").checked) {
            arc_shape = 0;
         }
         while ($("puzzlecontainer").firstChild) {
            $("puzzlecontainer").removeChild($("puzzlecontainer").firstChild);
         }
         coloring_seed = seed;
         jig.multipaths(frame, rad, arc_shape).forEach((p) => {
            var newpath = document.createElementNS($("puzzlecontainer").namespaceURI, "path")
            newpath.setAttribute("d", p);
            newpath.setAttribute("stroke", "black");
            newpath.setAttribute("stroke-width", rad / 20.0);
            newpath.setAttribute("fill", "#" + Math.floor(uniform(0, 16777216)).toString(16));
            $("puzzlecontainer").appendChild(newpath);
         });
         if (customborder.paths) {
            customborder.paths.forEach((p) => {
               var svgpathd = "M " + (p[0].pts()[0].x + rad) + ", " + (p[0].pts()[0].y + rad) + " "
               p.forEach((seg) => {
                  svgpathd += seg.svg(rad);
               });
               var framedraw = document.createElementNS($("puzzlecontainer").namespaceURI, "path")
               framedraw.setAttribute("d", svgpathd);
               framedraw.setAttribute("stroke", "black");
               framedraw.setAttribute("fill", "none");
               framedraw.setAttribute("stroke-width", 0.5);
               $("puzzlecontainer").appendChild(framedraw);
            });
         } else {
            var framedraw = document.createElementNS($("puzzlecontainer").namespaceURI, "path")
            framedraw.setAttribute("d", createframe());
            framedraw.setAttribute("stroke", "black");
            framedraw.setAttribute("fill", "none");
            framedraw.setAttribute("stroke-width", 0.5);
            $("puzzlecontainer").appendChild(framedraw);
         }
         // for (var i = 0; i < jig.nrows; i++) {
         //    for (var j = 0; j < jig.ncols; j++) {
         //       if (jig.maskgrid[i][j]) {
         //          var framedraw = document.createElementNS($("puzzlecontainer").namespaceURI, "circle")
         //          framedraw.setAttribute("cx", rad + 2 * rad * j);
         //          framedraw.setAttribute("cy", rad + 2 * rad * i);
         //          framedraw.setAttribute("r", rad);

         //          framedraw.setAttribute("fill", "red");
         //          framedraw.setAttribute("opacity", 0.2);
         //          $("puzzlecontainer").appendChild(framedraw);

         //       } else {
         //          var framedraw = document.createElementNS($("puzzlecontainer").namespaceURI, "circle")
         //          framedraw.setAttribute("cx", rad + 2 * rad * j);
         //          framedraw.setAttribute("cy", rad + 2 * rad * i);
         //          framedraw.setAttribute("r", rad);

         //          framedraw.setAttribute("fill", "green");
         //          framedraw.setAttribute("opacity", 0.2);
         //          $("puzzlecontainer").appendChild(framedraw);
         //       }
         //    }
         // }

         $("piececount").innerHTML = jig.npieces();

      }

      function loadborder() {
         var borderfile = $("borderfile");
         var fr = new FileReader();
         fr.readAsText(borderfile.files[0]);
         fr.onloadend = function () {
            //console.log(fr.result);
            var parser = new DOMParser();
            var xmldoc = parser.parseFromString(fr.result, "text/xml");
            var viewBox = xmldoc.getElementsByTagName("svg")[0];
            if (xmldoc.getElementsByTagName("svg")[0].width.baseVal.unitType == 2) {
               var width = Math.ceil(xmldoc.getElementsByTagName("svg")[0].width.baseVal.value);
               var height = Math.ceil(xmldoc.getElementsByTagName("svg")[0].height.baseVal.value);
            } else {
               var width = Math.ceil(xmldoc.getElementsByTagName("svg")[0].width.baseVal.valueInSpecifiedUnits);
               var height = Math.ceil(xmldoc.getElementsByTagName("svg")[0].height.baseVal.valueInSpecifiedUnits);
            }

            customborder.width = width;
            customborder.height = height;
            var paths_svg = xmldoc.getElementsByTagName("path");
            var g = xmldoc.getElementsByTagName("g");
            var xinit = 0, yinit = 0;
            if (g.length) {
               if (g[0].transform.baseVal.length) {
                  xinit = g[0].transform.baseVal[0].matrix.e;
                  yinit = g[0].transform.baseVal[0].matrix.f;
               }
            }
            var paths = [];
            for (let p of paths_svg) {
               var path = [];
               var current_pos = { x: xinit, y: yinit };
               for (let sl of p.animatedPathSegList) {
                  switch (sl.pathSegTypeAsLetter) {
                     case 'z':
                     case 'Z':
                        if (path.length) {
                           var l = new Bezier([{ x: current_pos.x, y: current_pos.y }, path[0].pts()[0]]);
                           path.push(l);
                        }
                        break;
                     case 'h':
                     case 'v':
                     case 'l':
                        var dx = 0;
                        var dy = 0;
                        if (sl.x) {
                           dx = sl.x;
                        }
                        if (sl.y) {
                           dy = sl.y;
                        }
                        var l = new Bezier([{ x: current_pos.x, y: current_pos.y }, { x: current_pos.x + dx, y: current_pos.y + dy }]);
                        current_pos.x += dx;
                        current_pos.y += dy;
                        path.push(l);
                        break;
                     case 'H':
                     case 'V':
                     case 'L':
                        var nx = current_pos.x;
                        var ny = current_pos.y;
                        if (sl.x) {
                           nx = sl.x + xinit;
                        }
                        if (sl.y) {
                           ny = sl.y + yinit;
                        }
                        var l = new Bezier([{ x: current_pos.x, y: current_pos.y }, { x: nx, y: ny }]);
                        current_pos.x = nx;
                        current_pos.y = ny;
                        path.push(l);
                        break;
                     case 'm':
                        current_pos.x += sl.x;
                        current_pos.y += sl.y;
                        break;
                     case 'M':
                        current_pos.x = sl.x + xinit;
                        current_pos.y = sl.y + yinit;
                        break;
                     case 't':
                        if (path.length && path[path.length - 1].stype() == 'Q') {
                           var lastpath = path[path.length - 1];
                           sl.x1 = lastpath.pts()[2].x - lastpath.pts()[1].x;
                           sl.y1 = lastpath.pts()[2].y - lastpath.pts()[1].y;
                        } else {
                           sl.x1 = 0;
                           sl.y1 = 0;
                        }
                     case 'q':
                        var bz = new Bezier([{ x: current_pos.x, y: current_pos.y }, { x: sl.x1 + current_pos.x, y: sl.y1 + current_pos.y }, { x: sl.x + current_pos.x, y: sl.y + current_pos.y }]);
                        current_pos.x += sl.x;
                        current_pos.y += sl.y;
                        path.push(bz);
                        break;
                     case 'T':
                        if (path.length && path[path.length - 1].stype() == 'Q') {
                           var lastpath = path[path.length - 1];
                           sl.x1 = 2 * lastpath.pts()[2].x - lastpath.pts()[1].x;
                           sl.y1 = 2 * lastpath.pts()[2].y - lastpath.pts()[1].y;
                        } else {
                           sl.x1 = current_pos.x;
                           sl.y1 = current_pos.y;
                        }
                     case 'Q':
                        var bz = new Bezier([{ x: current_pos.x, y: current_pos.y }, { x: sl.x1 + xinit, y: sl.y1 + yinit }, { x: sl.x + xinit, y: sl.y + yinit }]);
                        current_pos.x = sl.x + xinit;
                        current_pos.y = sl.y + yinit;
                        path.push(bz);
                        break;
                     case 's':
                        if (path.length && path[path.length - 1].stype() == 'C') {
                           var lastpath = path[path.length - 1];
                           sl.x1 = lastpath.pts()[3].x - lastpath.pts()[2].x;
                           sl.y1 = lastpath.pts()[3].y - lastpath.pts()[2].y;
                        } else {
                           sl.x1 = 0;
                           sl.y1 = 0;
                        }
                     case 'c':
                        var bz = new Bezier([{ x: current_pos.x, y: current_pos.y }, { x: sl.x1 + current_pos.x, y: sl.y1 + current_pos.y }, { x: sl.x2 + current_pos.x, y: sl.y2 + current_pos.y }, { x: sl.x + current_pos.x, y: sl.y + current_pos.y }]);
                        current_pos.x += sl.x;
                        current_pos.y += sl.y;
                        path.push(bz);
                        break;
                     case 'S':
                        if (path.length && path[path.length - 1].stype() == 'C') {
                           var lastpath = path[path.length - 1];
                           sl.x1 = 2 * lastpath.pts()[3].x - lastpath.pts()[2].x;
                           sl.y1 = 2 * lastpath.pts()[3].y - lastpath.pts()[2].y;
                        } else {
                           sl.x1 = current_pos.x;
                           sl.y1 = current_pos.y;
                        }
                     case 'C':
                        var bz = new Bezier([{ x: current_pos.x, y: current_pos.y }, { x: sl.x1 + xinit, y: sl.y1 + yinit }, { x: sl.x2 + xinit, y: sl.y2 + yinit }, { x: sl.x + xinit, y: sl.y + yinit }]);
                        current_pos.x = sl.x + xinit;
                        current_pos.y = sl.y + yinit;
                        path.push(bz);
                        break;
                     case 'a':
                        var a = new SVGArc({ x: current_pos.x, y: current_pos.y }, sl.r1, sl.r2, sl.angle, sl.largeArcFlag, sl.sweepFlag, { x: sl.x + current_pos.x, y: sl.y + current_pos.y });
                        current_pos.x += sl.x;
                        current_pos.y += sl.y;
                        path.push(a);
                        break;
                     case 'A':
                        var a = new SVGArc({ x: current_pos.x, y: current_pos.y }, sl.r1, sl.r2, sl.angle, sl.largeArcFlag, sl.sweepFlag, { x: sl.x + xinit, y: sl.y + yinit });
                        current_pos.x = sl.x + xinit;
                        current_pos.y = sl.y + yinit;
                        path.push(a);
                        break;
                     default:
                        console.log("Dunno what to do with ", sl.pathSegTypeAsLetter);
                        break;
                  }
               };
               paths.push(path);
            };
            customborder.paths = paths;

         };
      }
   </script>
</head>


<body onload="$('seed').value = Math.random() * 10000; updateseed();">
   <table>
      <tr>
         <td>Seed:</td>
         <td><input id="_seed" type="text" value="0" onchange="update_seed()" /></td>
         <td><input id="seed" type="range" value="0" min="0" max="9999" step="1" onchange="updateseed()" /></td>
      </tr>
      <tr>
         <td>Use non-deterministic randomness:</td>
         <td><input id="ndr" type="checkbox" />(seed is ignored if ticked)</td>
      </tr>
      <tr>
         <td>Tile shape:</td>
         <td>
            <input type="radio" checked="checked" id="circular" name="tileshape" value="circular">
            <label for="circular">Circular</label><br>
            <input type="radio" id="octagonal" name="tileshape" value="octagonal">
            <label for="octagonal">Octagonal</label><br>
            <input type="radio" id="square" name="tileshape" value="square">
            <label for="square">Square</label><br>
         </td>
      </tr>
      <tr>
         <td>Columns:</td>
         <td><input id="_ncols" type="text" value="20" onchange="update_ncols()" /></td>
         <td><input id="ncols" type="range" value="20" min="2" max="250" step="1" onchange="updatencols()" /></td>
      </tr>
      <tr>
         <td>Rows:</td>
         <td><input id="_nrows" type="text" value="20" onchange="update_nrows()" /></td>
         <td><input id="nrows" type="range" value="20" min="2" max="250" step="1" onchange="updatenrows()" /></td>
      </tr>
      <tr>
         <td>Tile Radius:</td>
         <td><input id="cradius" type="text" value="6.0" size="4" onchange="update()" /> mm</td>
         <td></td>
      </tr>
      <tr>
         <td>Frame size:</td>
         <td><input id="frame" type="text" value="6.0" size="4" onchange="update()" /> mm</td>
         <td></td>
      </tr>
      <tr>
         <td>Frame corner radius:</td>
         <td><input id="framecorner" type="text" value="4.0" size="4" onchange="update()" /> mm</td>
         <td></td>
      </tr>
      <tr>
         <td>Minimum pieze size:</td>
         <td><input id="minpsize" type="text" value="4" size="4" onchange="update()" /> tiles</td>
         <td></td>
      </tr>
      <tr>
         <td>Maximum piece size:</td>
         <td><input id="maxpsize" type="text" value="50" size="4" onchange="update()" /> tiles</td>
         <td></td>
      </tr>
      <tr>
         <td>Jigsaw size: <label id="width">w</label> x <label id="height">h</label> mm</td>
      </tr>

      </tr>
      <td>
         <input type="file" id="borderfile" accept=".svg">
         <button onclick="loadborder()">Load SVG border</button>
      </td>
      </tr>
      <tr>
         <td><button onclick="generate()">Generate Jigsaw</button></td>
      </tr>
      <tr>
         <td><button onclick="savesvg(3)">Download SVG (colored pieces)</button></td>
         <td><button onclick="savesvg(0)">Download SVG (individual pieces, overlap)</button></td>
      </tr>
      <tr>
         <td><button onclick="savesvg(1)">Download SVG (non-overlapping vectors)</button></td>
         <td><button onclick="savesvg(2)">Download SVG (non-overlapping vectors, single path)</button></td>
      </tr>
   </table>
   <svg id="puzzlecontainer">
      <!-- <path id="puzzlepath" fill="none" stroke="Black"></path> -->
   </svg>
   <table>
      <tr>
         <td>This jigsaw has: <label id="piececount">0</label> pieces</td>
      </tr>
   </table>
   <h2>What is this?</h2>
   <p>This is a "fractal" jigsaw puzzle generator.
      It creates jigsaws with a pattern that resembles the "inner" part of a space-filling fractal <a
         href="https://en.wikipedia.org/wiki/Dragon_curve">dragon curve</a>, although no fractal geometry is involved in
      the generation process. Additionally, I've found that some people like the texture it generates in single-piece
      mode (see below) and use it for lamp shades and such. This runs entirely on your computer (via your browser) and
      has no external library
      dependency, it's fully self-contained. You need a relatively modern browser for this to work. It has been tested
      on current versions (mid 2021)
      of Chrome, Firefox and Edge.</p>
   <p>These jigsaws are meant for laser-cutting.</p>
   <p>This is open-source software. Check the github repo <a
         href="https://github.com/proceduraljigsaw/Fractalpuzzlejs">here</a>.</p>
   <h2>How to use?</h2>
   <p>The jigsaw starts with tiles placed on a square grid. Each tile may be joined diagonally to its neighbors,
      creating
      the jigsaw pieces. The jigsaw is procedurally generated (using a computer algorithm), which internally uses a
      pseudorandom number generator to drive the
      process. These are the adjustable parameters:</p>
   <ul>
      <li><strong>Seed: </strong>It's the starting value for the deterministic, pseudorandom number generator used in
         the generation process. Seed value, grid dimensions (columns and rows) and piece tile count limits (min and max
         piece size) define unique jigsaw patterns that can be regenerated using the same input parameters. If you tick
         the "<strong>use non-deterministic randomness</strong>" checkbox, a non-deterministic random number generator
         is used instead, and a unique pattern is generated every time you press the "Generate Jigsaw" button. These
         patterns are truly unique and can't be regenerated ever again.</li>
      <li><strong>Columns and rows:&nbsp;</strong>The jigsaw tile grid dimensions. The larger the jigsaw, the longer it
         takes to generate.</li>
      <li><strong>Tile radius:</strong> The actual, physical radius of the jigsaw tiles, in millimeters. In octagonal
         tile mode, it's the radius of the circle inscribing the octagon tiles.</li>
      <li><strong>Frame size:</strong> Extra frame width surrounding the jigsaw.</li>
      <li><strong>Frame corner radius:</strong> The radius of the frame corners.</li>
      <li><strong>Minimum and maximum piece size:</strong> Minimum and maximum number of tiles allowed per piece.
         Minimum piece size will always be honored, while the maximum size may be overshot by some tiles because of how
         the generation algorithm works.</li>
      <li><strong>Custom border mode:</strong> Rectangular borders can get boring, so there's an option to upload a
         custom border to be used for your jigsaw. Press the file picker button on the left of the "Load SVG border
         Button" to open a file picker dialog. Choose the SVG file that you want to use as border, and then press the
         "Load SVG border" button BEFORE pressing "Generate Jigsaw". To "unload" the svg border and get back to the
         normal rectangular frame mode just reload the webpage. Some notes about Custom border mode:
         <ul>
            <li>Nothing is actually uploaded anywhere, everything stays on your computer, running inside your browser.
               Your SVG borders remain in your computer. You can totally use this offline.</li>
            <li>The border file must be:
               <ul>
                  <li>An SVG file, compliant to the SVG specification (don't use fancy features, pls).</li>
                  <li>No transforms allowed, except for traslation.</li>
                  <li>The dimensions of the jigsaw will be the numerical dimensions of your border, interpreted as
                     millimeters. If you set your units to pixels and draw a 500x500 pixel border, it will be
                     interpreted as 500x500mm. If you set it to inches and the dimensions are 6"x4", it ill be
                     interpreted as 6x4mm. So it's better if you just use millimeters for the SVG border.</li>
                  <li>May use relative or absolute coordinates, or a mix of both.</li>
                  <li>All paths must be inside the viewbox, if there's a viewbox.</li>
                  <li>It's much better if you adjust the viewbox to the border, so that the viewbox is the bounding box
                     of the border, with no extra space.</li>
                  <li>Must ONLY contain paths. No other kinds of SVG objects are allowed (for now). That means no
                     rectangles, circles, ellipses and such. Everything must be a path.</li>
                  <li>Paths must be closed. They don't neccesarily need to end in "Z" or "z", but they have to start and
                     end at the same point and form closed loops. And please, no path intersections.</li>
                  <li>It should support and poroperly render all SVG path commands (lines, beziers and elliptic arcs).
                  </li>
                  <li>Paths may be nested inside each other (i.e. you can make holes). The generator will find the
                     "inside" and "outside" of your border and only paint "inside". Holes are treated as "outside".
                     Holes inside holes are treated as "Inside". Holes inside holes inside holes are treated as
                     "outside", and so on.</li>
                  <li>Stuff drawn on inkscape usually works well.</li>
                  <li>Not sure what this all means? Check here: <a href="https://www.w3.org/TR/SVG11/">SVG
                        specification</a></li>
                  <li>TL;DR: pick any SVG from the internet that you're licensed to use with the shape you want and try
                     it. Maybe scale it with inkscape before to set the proper size.</li>
                  <li><span style="color: #ff0000;"><strong>This is NOT guaranteed to work, it has bugs and
                           limitations!</strong></span></li>
               </ul>
            </li>
         </ul>
      </li>
   </ul>
   <p>You may export the jigsaw to SVG in several ways:</p>
   <ul>
      <li><strong>Colored SVG:</strong> Export the jigsaw with colored pieces. Great to use for box covers or as the
         jigsaw solution. If you use non-deterministic randomness mode, the colors
         of the exported SVG will be different from those shown in the jigsaw preview.</li>
      <li><strong>Individual pieces with overlap:</strong> Export the pieces as overlapping closed paths. This can't be
         lasercut straight away, but it can be used for cutting individual pieces (for replacements or to cut them in a
         milling machine)</li>
      <li><strong>Non-overlapping:</strong> Vectors are exported with no overlap. It can be lasercut straight away.
         There's still some overlapping in octagonal shape mode, which is tricky to remove. You may want to use
         a vector editing software to remove the remaining overlaps. There are no overlaps in circular or square
         tile shape modes.</li>
      <li><strong>Non-overlapping, single path:</strong> Vectors are exported with no overlap, but the SVG is composed
         of a single path instead of multiple paths. Apparently this way it works better with Trotec machines for some
         reason.</li>
   </ul>
   <h2>Tips and tricks</h2>
   <h4>Single piece mode</h4>
   <p>If you set the minimum and maximum piece size to exactly half the number of tiles in the grid, it will generate a
      single piece jigsaw with a very interesting texture that some people are using for lampshades and such. </p>
   <p>For example, if your grid is 50 columns by 30 rows (50x30 =1500 tiles in total), set the minimum and maximum piece
      size to 1500/2 = 750 tiles for single piece mode</p>
   <h4>Trotec machines software tip</h4>
   <p>Apparently, Trotec machines have some issues with the SVGs generated by this generator and may crash or fail while
      cutting. Trotec software optimizes vectors by default converting everything to bezier curves before generating the
      laser cutting toolpath. These puzzles are made entirely of circular arcs (a rare edge case), which are hard to
      approximate with bezier curves. </p>
   <p>You have to disable this optimization to cut these jigsaws. There's an option in their JobControl software to
      disable it, but I don't know how to do it as I don't own a Trotec machine, so please contact Trotec for help.</p>
   <h4>Offline use</h4>
   <p>As this is fully self-contained, you may download the website's html (for most browsers by right-clicking on the
      website and selecting
      "Save As...") and just run it offline by opening the saved HTML with your browser. It doesn't need an Internet
      connection for
      anything as it has all the code embedded within the HTML.</p>

</body>

</html>